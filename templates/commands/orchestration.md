# Orchestration

Generate and manage parallel Claude Code orchestration for independent streams.

## Command Argument Handling

This command supports optional action arguments:

**Usage:**
- `/orchestration` or `/orchestration generate` - Generate orchestration scripts (default)
- `/orchestration config` - Show current orchestration configuration
- `/orchestration status` - Show stream progress and active sessions

## Action: Generate (Default)

Generate external orchestration scripts that enable running multiple Claude Code sessions in parallel for independent work streams.

### Step 1: Query Active Streams

Call `stream_list()` to retrieve all active streams in the current initiative.

**If no initiative exists:**
```
## No Active Initiative

Cannot generate orchestration without an active initiative.

To create an initiative:
1. Run /protocol
2. Work with @agent-ta to create a PRD with tasks
3. Ensure tasks are organized into streams

Or run /continue to resume a previous initiative.
```

**If no streams found:**
```
## No Streams Defined

Cannot generate orchestration without work streams.

Work streams enable parallel execution across multiple Claude Code sessions.

To create streams:
1. Work with @agent-ta to organize tasks into streams
2. Assign streamId, streamName, and streamPhase to tasks
3. Use streamPhase: 'foundation', 'parallel', or 'integration'

Run /orchestration once streams are defined.
```

### Step 2: Validate Stream Configuration

Check the following requirements:

1. **At least one foundation stream exists** (streamPhase: 'foundation')
2. **No circular dependencies** (validated by stream_list tool)
3. **File conflicts within streams are acceptable** (streams are independent)
4. **Maximum 5 parallel streams** (practical orchestration limit)

**If validation fails, display error:**
```
## Invalid Stream Configuration

Cannot generate orchestration due to configuration issues:

[List specific validation errors]

Please fix these issues and run /orchestration again.
```

### Step 3: Prepare Output Directory

Create `.claude/orchestration/` directory if it doesn't exist.

Display message:
```
## Generating Orchestration Scripts

Output directory: .claude/orchestration/
```

### Step 4: Generate orchestration-config.json

Create configuration file with current stream data:

```json
{
  "version": "1.0",
  "generatedAt": "[ISO timestamp]",
  "initiative": {
    "id": "[initiative ID]",
    "name": "[initiative name]"
  },
  "apiEndpoint": "http://127.0.0.1:9090",
  "streams": [
    {
      "streamId": "Stream-A",
      "streamName": "foundation",
      "streamPhase": "foundation",
      "totalTasks": 4,
      "completedTasks": 0,
      "dependencies": [],
      "projectRoot": "[absolute path to project]",
      "worktreePath": null
    },
    {
      "streamId": "Stream-B",
      "streamName": "command-updates",
      "streamPhase": "parallel",
      "totalTasks": 2,
      "completedTasks": 0,
      "dependencies": ["Stream-A"],
      "projectRoot": "[absolute path to project]",
      "worktreePath": ".claude/worktrees/Stream-B"
    }
  ],
  "executionPlan": {
    "foundation": ["Stream-A"],
    "parallel": ["Stream-B", "Stream-C"],
    "integration": ["Stream-Z"]
  }
}
```

### Step 5: Generate start-streams.py

Create the Python orchestration script:

```python
#!/usr/bin/env python3
"""
Claude Code Parallel Stream Orchestration

Manages multiple Claude Code sessions running in parallel for independent work streams.
Generated by: /orchestration command
"""

import json
import subprocess
import time
import requests
import sys
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime

# Configuration
CONFIG_FILE = Path(__file__).parent / "orchestration-config.json"
API_BASE = "http://127.0.0.1:9090"
POLL_INTERVAL = 30  # seconds
MAX_RETRIES = 3

@dataclass
class StreamStatus:
    """Current status of a stream."""
    stream_id: str
    stream_name: str
    stream_phase: str
    total_tasks: int
    completed_tasks: int
    in_progress_tasks: int
    progress_percentage: float
    dependencies: List[str]
    worktree_path: Optional[str]

class OrchestrationManager:
    """Manages parallel Claude Code sessions."""

    def __init__(self, config_path: Path):
        self.config = self._load_config(config_path)
        self.active_processes: Dict[str, subprocess.Popen] = {}

    def _load_config(self, path: Path) -> dict:
        """Load orchestration configuration."""
        if not path.exists():
            print(f"Error: Configuration file not found: {path}")
            sys.exit(1)

        with open(path) as f:
            return json.load(f)

    def _check_api_health(self) -> bool:
        """Check if Task Copilot HTTP API is available."""
        try:
            response = requests.get(f"{API_BASE}/health", timeout=5)
            return response.status_code == 200
        except requests.RequestException:
            return False

    def _get_stream_status(self, stream_id: str) -> Optional[StreamStatus]:
        """Query current stream status from API."""
        try:
            response = requests.get(f"{API_BASE}/api/streams/{stream_id}", timeout=5)
            if response.status_code == 404:
                return None

            data = response.json()
            return StreamStatus(
                stream_id=data["streamId"],
                stream_name=data["streamName"],
                stream_phase=data["streamPhase"],
                total_tasks=data.get("totalTasks", 0),
                completed_tasks=data.get("completedTasks", 0),
                in_progress_tasks=data.get("inProgressTasks", 0),
                progress_percentage=data.get("progressPercentage", 0.0),
                dependencies=data.get("dependencies", []),
                worktree_path=data.get("worktreePath")
            )
        except requests.RequestException as e:
            print(f"Warning: Failed to get status for {stream_id}: {e}")
            return None

    def _are_dependencies_complete(self, stream_id: str) -> bool:
        """Check if all stream dependencies are 100% complete."""
        stream_config = next(
            (s for s in self.config["streams"] if s["streamId"] == stream_id),
            None
        )
        if not stream_config:
            return False

        dependencies = stream_config.get("dependencies", [])
        if not dependencies:
            return True

        for dep_id in dependencies:
            status = self._get_stream_status(dep_id)
            if not status or status.progress_percentage < 100:
                return False

        return True

    def _start_stream_session(self, stream_id: str) -> bool:
        """Start a Claude Code session for a stream."""
        stream_config = next(
            (s for s in self.config["streams"] if s["streamId"] == stream_id),
            None
        )
        if not stream_config:
            print(f"Error: Stream {stream_id} not found in configuration")
            return False

        # Determine working directory
        project_root = Path(stream_config["projectRoot"])
        worktree_path = stream_config.get("worktreePath")

        if worktree_path:
            work_dir = project_root / worktree_path
        else:
            work_dir = project_root

        if not work_dir.exists():
            print(f"Error: Working directory does not exist: {work_dir}")
            return False

        # Launch Claude Code with /continue command
        # Note: This is a placeholder - actual command depends on environment
        # Users should modify this to match their Claude Code invocation method
        print(f"┌─ Starting session for {stream_id} ({stream_config['streamName']})")
        print(f"│  Working directory: {work_dir}")
        print(f"│  Command: claude")
        print(f"│  Initial command: /continue {stream_id}")
        print(f"└─ Session started")

        # Example process launch (modify for your environment):
        # proc = subprocess.Popen(
        #     ["claude"],
        #     cwd=work_dir,
        #     stdin=subprocess.PIPE,
        #     stdout=subprocess.PIPE,
        #     stderr=subprocess.PIPE
        # )
        # proc.stdin.write(f"/continue {stream_id}\n".encode())
        # proc.stdin.flush()
        # self.active_processes[stream_id] = proc

        return True

    def run_orchestration(self):
        """Execute the orchestration plan."""
        print("=" * 60)
        print("Claude Code Parallel Stream Orchestration")
        print("=" * 60)
        print()

        # Check API health
        print("Checking Task Copilot HTTP API...")
        if not self._check_api_health():
            print("Error: Task Copilot HTTP API is not available")
            print("Ensure Task Copilot MCP server is running with HTTP API enabled")
            sys.exit(1)
        print("✓ API is healthy")
        print()

        # Get execution plan
        plan = self.config["executionPlan"]

        # Phase 1: Foundation
        print("Phase 1: Foundation Streams")
        print("-" * 60)
        for stream_id in plan.get("foundation", []):
            status = self._get_stream_status(stream_id)
            if status and status.progress_percentage >= 100:
                print(f"✓ {stream_id} already complete")
                continue

            print(f"⚠ {stream_id} needs to be completed manually")
            print(f"  Run: /continue {stream_id}")
            print(f"  This is the foundation - must complete before parallel streams")

        print()
        input("Press Enter when foundation streams are complete...")
        print()

        # Verify foundation complete
        foundation_complete = all(
            self._get_stream_status(sid).progress_percentage >= 100
            for sid in plan.get("foundation", [])
            if self._get_stream_status(sid)
        )

        if not foundation_complete:
            print("Error: Foundation streams not complete. Exiting.")
            sys.exit(1)

        # Phase 2: Parallel Streams
        print("Phase 2: Parallel Streams")
        print("-" * 60)
        parallel_streams = plan.get("parallel", [])

        print(f"Starting {len(parallel_streams)} parallel sessions...")
        for stream_id in parallel_streams:
            self._start_stream_session(stream_id)

        print()
        print("Monitoring progress (Ctrl+C to stop)...")
        print()

        try:
            while True:
                all_complete = True
                for stream_id in parallel_streams:
                    status = self._get_stream_status(stream_id)
                    if not status:
                        continue

                    progress_bar = "█" * int(status.progress_percentage / 5)
                    progress_bar = progress_bar.ljust(20, "░")

                    print(f"{stream_id}: [{progress_bar}] {status.progress_percentage:.0f}% " +
                          f"({status.completed_tasks}/{status.total_tasks} tasks)")

                    if status.progress_percentage < 100:
                        all_complete = False

                print()

                if all_complete:
                    print("✓ All parallel streams complete!")
                    break

                time.sleep(POLL_INTERVAL)

        except KeyboardInterrupt:
            print("\nOrchestration interrupted by user")
            sys.exit(0)

        # Phase 3: Integration
        integration_streams = plan.get("integration", [])
        if integration_streams:
            print()
            print("Phase 3: Integration Streams")
            print("-" * 60)
            for stream_id in integration_streams:
                print(f"⚠ {stream_id} ready to start")
                print(f"  Run: /continue {stream_id}")

            print()
            print("Run integration streams manually to merge parallel work.")

        print()
        print("=" * 60)
        print("Orchestration complete!")
        print("=" * 60)


if __name__ == "__main__":
    manager = OrchestrationManager(CONFIG_FILE)
    manager.run_orchestration()
```

### Step 6: Generate README.md

Create usage documentation:

```markdown
# Claude Code Parallel Orchestration

This directory contains generated scripts for orchestrating parallel Claude Code sessions across independent work streams.

## Generated Files

- **orchestration-config.json** - Stream configuration and execution plan
- **start-streams.py** - Python orchestration script
- **README.md** - This file

## Prerequisites

1. **Task Copilot HTTP API must be running**
   - Configured in `.mcp.json` with `HTTP_API_PORT` (default: 9090)
   - API provides stream status and task progress

2. **Python 3.8+** with `requests` library:
   ```bash
   pip install requests
   ```

3. **Foundation streams must be complete** before starting parallel work

## Quick Start

1. **Review the configuration:**
   ```bash
   cat orchestration-config.json
   ```

2. **Start orchestration:**
   ```bash
   python start-streams.py
   ```

3. **Follow the prompts:**
   - Complete foundation streams first (manually)
   - Script will start parallel sessions
   - Monitor progress in real-time
   - Complete integration streams last (manually)

## Execution Phases

### Phase 1: Foundation
Shared infrastructure that other streams depend on. Must complete before parallel work begins.

**Streams:** [list foundation stream IDs]

**How to run:**
```bash
claude
/continue Stream-A
```

Work through all tasks in the foundation stream until 100% complete.

### Phase 2: Parallel
Independent streams that can run simultaneously in separate Claude Code sessions.

**Streams:** [list parallel stream IDs]

**How to run:**
The orchestration script will guide you through starting parallel sessions. Each session runs in its own terminal/window.

Alternatively, start manually:
```bash
# Terminal 1
claude
/continue Stream-B

# Terminal 2
claude
/continue Stream-C
```

### Phase 3: Integration
Combines work from parallel streams. Runs after all parallel streams complete.

**Streams:** [list integration stream IDs]

**How to run:**
```bash
claude
/continue Stream-Z
```

## Monitoring Progress

### Real-time Monitoring (Automated)
The orchestration script polls the HTTP API every 30 seconds and displays progress bars.

### Manual Status Check
```bash
# In any Claude Code session:
/orchestration status

# Or query the API directly:
curl http://127.0.0.1:9090/api/streams
```

## Worktree Isolation

Parallel streams use Git worktrees for complete file isolation:

- **Foundation/Integration:** Work in main worktree (project root)
- **Parallel streams:** Each has its own worktree in `.claude/worktrees/Stream-X`

The `/continue` command automatically:
- Creates worktrees if needed
- Switches to the correct worktree
- Isolates file changes

## Troubleshooting

### HTTP API Not Available

**Error:** "Task Copilot HTTP API is not available"

**Fix:**
1. Ensure Task Copilot MCP server is running
2. Check `.mcp.json` configuration includes `HTTP_API_PORT`
3. Verify server is listening: `curl http://127.0.0.1:9090/health`

### Stream Not Found

**Error:** "Stream not found: Stream-X"

**Fix:**
1. Verify stream exists: `/orchestration status`
2. Check stream wasn't archived (archived streams hidden by default)
3. Unarchive if needed: Use `stream_unarchive({ streamId: "Stream-X" })`

### Foundation Not Complete

**Error:** "Foundation streams not complete"

**Fix:**
1. Check foundation stream status: `/orchestration status`
2. Complete all foundation tasks before starting parallel work
3. Foundation must be 100% complete

### Worktree Conflicts

**Error:** "Worktree already exists"

**Fix:**
```bash
# List worktrees
git worktree list

# Remove stale worktree
git worktree remove .claude/worktrees/Stream-X

# Prune stale references
git worktree prune
```

## Customization

### Modify Polling Interval

Edit `start-streams.py`:
```python
POLL_INTERVAL = 30  # Change to desired seconds
```

### Change API Endpoint

Edit `orchestration-config.json`:
```json
"apiEndpoint": "http://127.0.0.1:9090"
```

### Custom Session Launch

The script includes a placeholder for launching Claude Code sessions. Modify `_start_stream_session()` to match your environment (iTerm, tmux, screen, etc.).

## Re-generating Scripts

If stream configuration changes, regenerate:
```bash
claude
/orchestration generate
```

This overwrites existing files with updated configuration.

## Next Steps

1. Complete foundation streams
2. Run `python start-streams.py` to start parallel orchestration
3. Monitor progress in real-time
4. Complete integration streams after parallel work finishes
5. Merge stream branches as needed

For more information, see:
- Stream documentation: `docs/TASK-WORKTREE-ISOLATION.md`
- HTTP API docs: `HTTP_IMPLEMENTATION.md`
```

### Step 7: Make Scripts Executable

Make the Python script executable:
```bash
chmod +x .claude/orchestration/start-streams.py
```

### Step 8: Display Success Message

```
## Orchestration Scripts Generated

Created files:
- .claude/orchestration/orchestration-config.json
- .claude/orchestration/start-streams.py
- .claude/orchestration/README.md

Next steps:
1. Review the configuration: cat .claude/orchestration/orchestration-config.json
2. Read the README: cat .claude/orchestration/README.md
3. Start orchestration: python .claude/orchestration/start-streams.py

Note: Foundation streams must complete before parallel streams can begin.

Stream summary:
[Display execution plan with stream counts by phase]
```

## Action: Config

Display current orchestration configuration if it exists.

### Step 1: Check for Configuration File

Look for `.claude/orchestration/orchestration-config.json`.

**If file exists:**

```
## Current Orchestration Configuration

Generated: [generatedAt timestamp]
Initiative: [initiative name] ([initiative ID])
API Endpoint: [apiEndpoint]

Stream Summary:
- Foundation: [count] stream(s)
- Parallel: [count] stream(s)
- Integration: [count] stream(s)

Configuration file: .claude/orchestration/orchestration-config.json

To view full configuration:
cat .claude/orchestration/orchestration-config.json

To regenerate:
/orchestration generate
```

**If file does not exist:**

```
## No Orchestration Configuration Found

No orchestration scripts have been generated yet.

To generate orchestration scripts:
/orchestration generate

This will create:
- orchestration-config.json
- start-streams.py
- README.md
```

## Action: Status

Display current stream progress and status.

### Step 1: Query Stream Status

Call `stream_list()` to get all active streams.

**If no initiative:**
```
## No Active Initiative

Cannot show stream status without an active initiative.

Run /continue or /protocol to start working.
```

**If no streams:**
```
## No Streams Found

No work streams defined in current initiative.

Streams enable parallel orchestration. To create streams:
1. Organize tasks with streamId, streamName, streamPhase metadata
2. Run /orchestration generate to create orchestration scripts
```

### Step 2: Display Stream Status

For each stream, show progress and task breakdown:

```
## Stream Status

Total streams: [count]
Active sessions: [count of streams with in_progress tasks]

### Foundation Phase

Stream-A (foundation)
├─ Progress: ████████████████████ 100% (4/4 tasks)
├─ Status: Complete ✓
├─ Files: src/types.ts, src/tools/stream.ts
└─ Dependencies: None

### Parallel Phase

Stream-B (command-updates)
├─ Progress: ██████████░░░░░░░░░░ 50% (1/2 tasks)
├─ Status: In Progress
├─ Worktree: .claude/worktrees/Stream-B
├─ Branch: stream-b
├─ Files: .claude/commands/protocol.md, .claude/commands/continue.md
└─ Dependencies: Stream-A ✓

Stream-C (agent-updates)
├─ Progress: ░░░░░░░░░░░░░░░░░░░░ 0% (0/3 tasks)
├─ Status: Pending
├─ Worktree: .claude/worktrees/Stream-C
├─ Branch: stream-c
├─ Files: .claude/agents/ta.md
└─ Dependencies: Stream-A ✓

### Integration Phase

Stream-Z (integration)
├─ Progress: ░░░░░░░░░░░░░░░░░░░░ 0% (0/2 tasks)
├─ Status: Blocked (dependencies incomplete)
├─ Files: docs/*, README.md
└─ Dependencies: Stream-B (50%), Stream-C (0%)

---

Legend:
✓ Complete | ⚠ In Progress | ⏸ Pending | ⚫ Blocked

To start orchestration: /orchestration generate
To view configuration: /orchestration config
```

### Step 3: Show Next Actions

Based on stream status, suggest next actions:

```
## Suggested Next Actions

[If foundation incomplete:]
1. Complete foundation streams first (required for parallel work)
   Run: /continue Stream-A

[If foundation complete, parallel not started:]
1. Start parallel orchestration
   Run: /orchestration generate
   Then: python .claude/orchestration/start-streams.py

[If parallel in progress:]
1. Continue working on in-progress streams
2. Monitor progress: /orchestration status

[If parallel complete, integration not started:]
1. Begin integration streams
   Run: /continue Stream-Z
```

## Error Handling

### Stream Tools Unavailable

If `stream_list`, `stream_get` tools are not available:

```
## Orchestration Unavailable

The orchestration feature requires Task Copilot MCP server with stream support.

Ensure:
1. Task Copilot is configured in .mcp.json
2. Server version supports stream tools (v1.7.0+)
3. MCP server is running

To check: Look for task-copilot in MCP server list
```

### Task Copilot HTTP API Not Running

If generating scripts but HTTP API is not available:

```
## Warning: HTTP API Not Detected

Orchestration scripts require Task Copilot HTTP API.

The scripts will be generated, but won't work until HTTP API is enabled.

To enable HTTP API, add to .mcp.json:
{
  "mcpServers": {
    "task-copilot": {
      "env": {
        "HTTP_API_PORT": "9090"
      }
    }
  }
}

Then restart Claude Code.
```

### Permission Errors

If unable to create `.claude/orchestration/` directory or write files:

```
## Error: Permission Denied

Cannot create orchestration directory or files.

Attempted: .claude/orchestration/

Check:
1. Write permissions for .claude/ directory
2. Disk space available
3. Directory is not read-only
```

## Implementation Notes

- Use `stream_list()` to query stream data from Task Copilot
- Generate files using the Write tool (absolute paths)
- Create `.claude/orchestration/` if it doesn't exist
- Make `start-streams.py` executable with `chmod +x`
- Include current timestamp in generated config
- Use absolute paths for projectRoot in config
- Calculate execution plan by grouping streams by phase
- Default action is `generate` if no argument provided
- Commands are idempotent - safe to run multiple times
- Always check for active initiative before proceeding
- Display progress using ASCII progress bars (█ for complete, ░ for incomplete)
- Format percentages without decimals for cleaner display
