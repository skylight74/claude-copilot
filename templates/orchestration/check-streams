#!/bin/bash
# Quick status check for all streams with detailed task progress
# Usage: check-streams
# Compatible with bash 3.2+ (macOS default)
#
# Features:
# - Initiative-scoped stream filtering (only shows current initiative's streams)
# - Empty state handling (no initiative, no streams, all complete)
# - Initiative name and goal display in header

# Get script directory from original invocation path (don't resolve symlinks)
# This ensures PROJECT_ROOT is calculated from the project's .claude/orchestrator,
# not from a template directory if check-streams is symlinked
INVOCATION_PATH="${BASH_SOURCE[0]}"
INVOCATION_DIR="$(cd "$(dirname "$INVOCATION_PATH")" && pwd)"
PROJECT_ROOT="$(cd "$INVOCATION_DIR/../.." && pwd)"

# For finding companion scripts, use the resolved path (they may be in template)
SCRIPT_PATH="$INVOCATION_PATH"
while [ -L "$SCRIPT_PATH" ]; do
    RESOLVED_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$RESOLVED_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
cd "$PROJECT_ROOT"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'

# Orchestrator directories
ORCHESTRATOR_DIR="$PROJECT_ROOT/.claude/orchestrator"
PID_DIR="$ORCHESTRATOR_DIR/pids"
LOG_DIR="$ORCHESTRATOR_DIR/logs"

# Task Copilot database - detect workspace ID from project directory name
WORKSPACE_ID=$(basename "$PROJECT_ROOT")
DB_PATH="$HOME/.claude/tasks/$WORKSPACE_ID/tasks.db"

# Check if a worker process is running
is_worker_running() {
    local stream_id=$1
    local pid_file="$PID_DIR/${stream_id}.pid"

    if [ ! -f "$pid_file" ]; then
        return 1
    fi

    local pid=$(cat "$pid_file" 2>/dev/null)
    if [ -z "$pid" ]; then
        return 1
    fi

    # Check if process exists with kill -0
    if ! kill -0 "$pid" 2>/dev/null; then
        return 1
    fi

    # Double-check with ps to detect zombie processes
    # Zombies pass kill -0 but ps -p will fail
    ps -p "$pid" -o pid= >/dev/null 2>&1
    return $?
}

# Get log file path for a stream (per-initiative first, then legacy fallback)
get_log_file() {
    local stream_id=$1
    local init_id=$2

    # Try per-initiative log first
    if [ -n "$init_id" ]; then
        local per_init_log="$LOG_DIR/${stream_id}_${init_id:0:8}.log"
        if [ -f "$per_init_log" ]; then
            echo "$per_init_log"
            return
        fi
    fi

    # Fall back to legacy log
    local legacy_log="$LOG_DIR/${stream_id}.log"
    if [ -f "$legacy_log" ]; then
        echo "$legacy_log"
        return
    fi

    # No log found
    echo ""
}

# Get last N lines from worker log
get_worker_last_lines() {
    local stream_id=$1
    local num_lines=${2:-10}
    local log_file=$(get_log_file "$stream_id" "$INITIATIVE_ID")

    if [ -n "$log_file" ] && [ -f "$log_file" ]; then
        tail -n "$num_lines" "$log_file" 2>/dev/null | grep -v "^$"
    fi
}

# Get stream start time from log file (most recent session)
# Returns Unix timestamp or empty if not found
get_stream_start_time() {
    local stream_id=$1
    local log_file=$(get_log_file "$stream_id" "$INITIATIVE_ID")

    if [ -z "$log_file" ] || [ ! -f "$log_file" ]; then
        echo ""
        return
    fi

    # Find the last "Started:" line in the log (most recent session)
    local started_line=$(grep "^Started:" "$log_file" | tail -1)
    if [ -z "$started_line" ]; then
        echo ""
        return
    fi

    # Extract ISO timestamp: "Started: 2026-01-12T10:21:35.336549"
    local timestamp=$(echo "$started_line" | sed 's/Started: //' | cut -d'.' -f1)

    # Convert to Unix timestamp (macOS compatible)
    if [ -n "$timestamp" ]; then
        # Replace T with space for date parsing
        local date_str=$(echo "$timestamp" | tr 'T' ' ')
        # macOS date command
        date -j -f "%Y-%m-%d %H:%M:%S" "$date_str" "+%s" 2>/dev/null
    fi
}

# Format duration in compact form: 45m, 2h31m, 1d4h
format_duration() {
    local seconds=$1

    if [ -z "$seconds" ] || [ "$seconds" -le 0 ] 2>/dev/null; then
        echo "---"
        return
    fi

    local days=$((seconds / 86400))
    local hours=$(( (seconds % 86400) / 3600 ))
    local minutes=$(( (seconds % 3600) / 60 ))

    if [ "$days" -gt 0 ]; then
        echo "${days}d${hours}h"
    elif [ "$hours" -gt 0 ]; then
        echo "${hours}h${minutes}m"
    elif [ "$minutes" -gt 0 ]; then
        echo "${minutes}m"
    else
        echo "<1m"
    fi
}

# Get runtime for a stream
# For running streams: elapsed time from start
# For completed streams: total runtime (start to now, since we don't track end time)
get_stream_runtime() {
    local stream_id=$1
    local start_ts=$(get_stream_start_time "$stream_id")

    if [ -z "$start_ts" ]; then
        echo "---"
        return
    fi

    local now_ts=$(date "+%s")
    local elapsed=$((now_ts - start_ts))

    format_duration "$elapsed"
}

# Parse worker status from log output
get_worker_status() {
    local stream_id=$1
    local last_lines=$(get_worker_last_lines "$stream_id" 20)

    # Check if running
    if ! is_worker_running "$stream_id"; then
        # Check if completed
        if echo "$last_lines" | grep -qE "(Complete|completed|success)"; then
            echo "COMPLETED"
        elif [ -f "$PID_DIR/${stream_id}.pid" ]; then
            echo "STOPPED"
        else
            echo "NOT_STARTED"
        fi
        return
    fi

    # Running - check activity
    if echo "$last_lines" | grep -qiE "complete|finished|done"; then
        echo "FINISHING"
    elif echo "$last_lines" | grep -qE "(Reading|Writing|Editing|Searching|Running)"; then
        echo "WORKING"
    elif echo "$last_lines" | grep -qiE "(error|failed|blocked)"; then
        echo "ERROR"
    else
        echo "RUNNING"
    fi
}

# Read task progress from Task Copilot using Python client
read_orchestrator_data() {
    python3 "$SCRIPT_DIR/check_streams_data.py" "$WORKSPACE_ID" 2>/dev/null
}

# Read orchestrator data
ORCHESTRATOR_DATA=$(read_orchestrator_data 2>/dev/null)

# Check for empty states
FIRST_LINE=$(echo "$ORCHESTRATOR_DATA" | head -1)

clear

# Handle empty states
case "$FIRST_LINE" in
    "NO_DATABASE")
        echo -e "${BOLD}$(echo "$WORKSPACE_ID" | tr '[:lower:]' '[:upper:]')${NC}"
        echo "═══════════════════════════════════════════════════════════════════════════"
        echo ""
        echo -e "  ${DIM}No task data available${NC}"
        echo ""
        echo -e "  ${CYAN}To get started:${NC}"
        echo -e "    1. Run ${BOLD}/orchestrate generate${NC} to create PRD and tasks"
        echo -e "    2. Run ${BOLD}/orchestrate start${NC} to begin parallel execution"
        echo ""
        echo "═══════════════════════════════════════════════════════════════════════════"
        echo -e "${DIM}Workers: 0 | Data: Task Copilot | $(date '+%H:%M:%S')${NC}"
        exit 0
        ;;
    "NO_INITIATIVE")
        echo -e "${BOLD}$(echo "$WORKSPACE_ID" | tr '[:lower:]' '[:upper:]')${NC}"
        echo "═══════════════════════════════════════════════════════════════════════════"
        echo ""
        echo -e "  ${YELLOW}No currently running initiatives${NC}"
        echo ""
        echo -e "  ${CYAN}To get started:${NC}"
        echo -e "    1. Run ${BOLD}/protocol${NC} or ${BOLD}/orchestrate generate${NC} to start an initiative"
        echo -e "    2. Memory Copilot will track your progress"
        echo ""
        echo "═══════════════════════════════════════════════════════════════════════════"
        echo -e "${DIM}Workers: 0 | Data: Task Copilot + Memory Copilot (initiative-scoped) | $(date '+%H:%M:%S')${NC}"
        exit 0
        ;;
    "NO_STREAMS"|"NO_ACTIVE_STREAMS")
        # Parse initiative info if present
        INITIATIVE_LINE=$(echo "$ORCHESTRATOR_DATA" | grep "^INITIATIVE")
        if [ -n "$INITIATIVE_LINE" ]; then
            INITIATIVE_INFO="${INITIATIVE_LINE#INITIATIVE }"
            INITIATIVE_NAME="${INITIATIVE_INFO%%|*}"
            INITIATIVE_GOAL="${INITIATIVE_INFO#*|}"
        else
            INITIATIVE_NAME=""
            INITIATIVE_GOAL=""
        fi

        echo -e "${BOLD}$(echo "$WORKSPACE_ID" | tr '[:lower:]' '[:upper:]')${NC}"
        if [ -n "$INITIATIVE_NAME" ]; then
            echo -e "${CYAN}${INITIATIVE_NAME}${NC}"
            if [ -n "$INITIATIVE_GOAL" ]; then
                # Truncate goal to 70 chars
                GOAL_DISPLAY=$(echo "$INITIATIVE_GOAL" | cut -c1-70)
                echo -e "${DIM}${GOAL_DISPLAY}${NC}"
            fi
        fi
        echo "═══════════════════════════════════════════════════════════════════════════"
        echo ""
        if [ "$FIRST_LINE" = "NO_ACTIVE_STREAMS" ]; then
            echo -e "  ${GREEN}✓ All streams completed in current initiative${NC}"
        else
            echo -e "  ${DIM}No streams in current initiative${NC}"
        fi
        echo ""
        echo -e "  ${CYAN}Options:${NC}"
        echo -e "    • Run ${BOLD}/orchestrate generate${NC} to create new tasks"
        echo -e "    • Run ${BOLD}/continue${NC} to resume previous work"
        echo ""
        echo "═══════════════════════════════════════════════════════════════════════════"
        echo -e "${DIM}Workers: 0 | Data: Task Copilot + Memory Copilot (initiative-scoped) | $(date '+%H:%M:%S')${NC}"
        exit 0
        ;;
esac

# Parse initiative info (format: INITIATIVE <id>|<name>|<goal>)
INITIATIVE_LINE=$(echo "$ORCHESTRATOR_DATA" | grep "^INITIATIVE")
if [ -n "$INITIATIVE_LINE" ]; then
    INITIATIVE_INFO="${INITIATIVE_LINE#INITIATIVE }"
    INITIATIVE_ID="${INITIATIVE_INFO%%|*}"
    INITIATIVE_REST="${INITIATIVE_INFO#*|}"
    INITIATIVE_NAME="${INITIATIVE_REST%%|*}"
    INITIATIVE_GOAL="${INITIATIVE_REST#*|}"
    # Short ID for log file naming (first 8 chars)
    SHORT_INIT_ID="${INITIATIVE_ID:0:8}"
else
    INITIATIVE_ID=""
    INITIATIVE_NAME=""
    INITIATIVE_GOAL=""
    SHORT_INIT_ID=""
fi

# Parse overall stats
OVERALL_LINE=$(echo "$ORCHESTRATOR_DATA" | grep "^OVERALL")
read -r _ O_COMPLETED O_TOTAL O_INPROG O_PENDING O_PCT <<< "$OVERALL_LINE"

# Check for ALL_STREAMS_COMPLETE flag
ALL_COMPLETE=$(echo "$ORCHESTRATOR_DATA" | grep -c "^ALL_STREAMS_COMPLETE")

# Check worker processes
RUNNING_COUNT=$(find "$PID_DIR" -name "*.pid" -type f 2>/dev/null | wc -l | tr -d ' ')

# Build header with initiative info
HEADER=$(echo "$WORKSPACE_ID" | tr '[:lower:]' '[:upper:]')
echo -e "${BOLD}${HEADER}${NC}"

# Show initiative name and goal if available
if [ -n "$INITIATIVE_NAME" ]; then
    echo -e "${CYAN}${INITIATIVE_NAME}${NC}"
    if [ -n "$INITIATIVE_GOAL" ]; then
        # Truncate goal to 70 chars
        GOAL_DISPLAY=$(echo "$INITIATIVE_GOAL" | cut -c1-70)
        echo -e "${DIM}${GOAL_DISPLAY}${NC}"
    fi
fi

# Build compact stats line
if [ "$O_TOTAL" -gt 0 ] 2>/dev/null; then
    # Build stats: 60% ✓54 ⚙1 ○35
    STATS="${O_PCT}% ${GREEN}✓${O_COMPLETED}${NC}"
    if [ "${O_INPROG:-0}" -gt 0 ] 2>/dev/null; then
        STATS="${STATS} ${YELLOW}⚙${O_INPROG}${NC}"
    fi
    STATS="${STATS} ${DIM}○${O_PENDING}${NC}"
    echo -e "${STATS}"
fi

echo "═══════════════════════════════════════════════════════════════════════════"

# Process each stream from database
echo "$ORCHESTRATOR_DATA" | grep "^STREAM" | while read -r LINE; do
    # Parse: STREAM <id> <completed> <total> <pct> <in_progress> <pending> <blocked> <stream_name...>
    read -r _ STREAM_ID S_COMP S_TOT S_PCT S_INPROG S_PEND S_BLOCK STREAM_NAME_RAW <<< "$LINE"

    # Truncate stream name to 19 chars (shortened to make room for runtime column)
    if [ -n "$STREAM_NAME_RAW" ]; then
        STREAM_NAME=$(echo "$STREAM_NAME_RAW" | cut -c1-19)
    else
        STREAM_NAME=""
    fi

    WORKER_STATUS=$(get_worker_status "$STREAM_ID")

    # Determine status code (4 chars max) using progress percentage
    # Logic:
    #   No PID + progress < 100% = ---
    #   No PID + progress = 100% = DONE
    #   Active PID + progress < 100% = RUN
    #   Active PID + progress = 100% = FIN

    if is_worker_running "$STREAM_ID"; then
        # Worker is active
        if [ "$S_PCT" -eq 100 ] 2>/dev/null; then
            # 100% + active PID = finishing/cleanup
            STATUS="${GREEN}FIN${NC}"
            STATUS_RAW="FIN"
        elif [ "$WORKER_STATUS" = "ERROR" ]; then
            STATUS="${RED}ERR${NC}"
            STATUS_RAW="ERR"
        else
            # < 100% + active PID = running
            STATUS="${YELLOW}RUN${NC}"
            STATUS_RAW="RUN"
        fi
    else
        # No active worker
        if [ "$S_PCT" -eq 100 ] 2>/dev/null; then
            # 100% + no PID = done
            STATUS="${GREEN}DONE${NC}"
            STATUS_RAW="DONE"
        elif [ "$WORKER_STATUS" = "STOPPED" ]; then
            STATUS="${RED}STOP${NC}"
            STATUS_RAW="STOP"
        else
            # < 100% + no PID = not started/idle
            STATUS="${DIM}---${NC}"
            STATUS_RAW="---"
        fi
    fi

    # Build mini progress bar (15 chars)
    if [ "$S_TOT" != "?" ] && [ "$S_TOT" -gt 0 ] 2>/dev/null; then
        MINI_FILLED=$((S_PCT * 15 / 100))
        MINI_BAR=""
        i=0
        while [ $i -lt $MINI_FILLED ]; do MINI_BAR="${MINI_BAR}="; i=$((i + 1)); done
        while [ $i -lt 15 ]; do MINI_BAR="${MINI_BAR}-"; i=$((i + 1)); done

        # Don't color the bar itself to save on terminal codes
        PCT_STR="${S_PCT}%"
    else
        MINI_BAR="---------------"
        PCT_STR="  0%"
        S_COMP=0
        S_INPROG=0
        S_PEND=0
    fi

    # Build task counts with fixed column widths
    # Column widths: completed(4) in-progress(3) pending(3)
    COMP_STR=$(printf "%3s" "${S_COMP}")
    if [ "${S_INPROG:-0}" -gt 0 ] 2>/dev/null; then
        INPROG_STR=$(printf "%2s" "${S_INPROG}")
    else
        INPROG_STR="  "
    fi
    if [ "${S_PEND:-0}" -gt 0 ] 2>/dev/null; then
        PEND_STR=$(printf "%2s" "${S_PEND}")
    else
        PEND_STR="  "
    fi

    # Format percentage with fixed width (right-aligned)
    PCT_DISPLAY=$(printf "%3s%%" "${S_PCT}")

    # Get runtime for this stream
    RUNTIME=$(get_stream_runtime "$STREAM_ID")
    RUNTIME_DISPLAY=$(printf "%5s" "$RUNTIME")

    # Format stream name (19 chars, left-aligned) - shortened to make room for runtime
    if [ -n "$STREAM_NAME" ]; then
        NAME_DISPLAY=$(printf "%-19s" "$(echo "$STREAM_NAME" | cut -c1-19)")
    else
        NAME_DISPLAY=""
    fi

    # Build complete line with fixed columns (with runtime)
    # Stream-A [===============] 100%  ✓  3        DONE  2h31m  Foundation
    printf "%-8s [%s] %s  ${GREEN}✓%s${NC}" "$STREAM_ID" "$MINI_BAR" "$PCT_DISPLAY" "$COMP_STR"

    if [ "${S_INPROG:-0}" -gt 0 ] 2>/dev/null; then
        printf " ${YELLOW}⚙%s${NC}" "$INPROG_STR"
    else
        printf "    "
    fi

    if [ "${S_PEND:-0}" -gt 0 ] 2>/dev/null; then
        printf " ${DIM}○%s${NC}" "$PEND_STR"
    else
        printf "    "
    fi

    printf "  %b" "$STATUS"

    # Show runtime (dimmed for completed, cyan for running, --- for not started)
    if [ "$STATUS_RAW" = "---" ]; then
        # Stream hasn't started in current initiative - don't show stale runtime
        printf "  ${DIM}%5s${NC}" "---"
    elif [ "$S_PCT" -eq 100 ] 2>/dev/null; then
        printf "  ${DIM}%s${NC}" "$RUNTIME_DISPLAY"
    else
        printf "  ${CYAN}%s${NC}" "$RUNTIME_DISPLAY"
    fi

    if [ -n "$NAME_DISPLAY" ]; then
        printf "  %s" "$NAME_DISPLAY"
    fi

    printf "\n"
done

echo "═══════════════════════════════════════════════════════════════════════════"

# Show compact footer with initiative-scoped indicator
if [ "$RUNNING_COUNT" -gt 0 ] 2>/dev/null; then
    echo -e "${DIM}Workers: ${RUNNING_COUNT} | Data: Task Copilot + Memory Copilot (initiative-scoped) | $(date '+%H:%M:%S')${NC}"
else
    echo -e "${DIM}Workers: 0 | Data: Task Copilot + Memory Copilot (initiative-scoped) | $(date '+%H:%M:%S')${NC}"
fi
