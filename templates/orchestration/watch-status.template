#!/usr/bin/env python3
"""
Claude Code Orchestration Status Monitor

Real-time terminal display of parallel stream progress and agent activity.

Features:
- Live terminal updates with clear screen refresh
- Progress bars with Unicode characters (█ and ░)
- Color coding: green=complete, yellow=active, red=blocked
- Agent activity per stream
- Alerts section for blocked streams
- Graceful keyboard interrupt handling
- Configurable refresh interval

Usage:
    python3 watch-status.py              # Default 5s refresh
    python3 watch-status.py --refresh 10 # Custom refresh interval
    python3 watch-status.py --no-color   # Disable ANSI colors

Generated by: /orchestration command
API endpoint: http://127.0.0.1:9090
"""

import argparse
import json
import sys
import time
from datetime import datetime
from typing import Dict, List, Optional, Tuple

try:
    import requests
except ImportError:
    print("Error: 'requests' library not found")
    print("Install with: pip install requests")
    sys.exit(1)

# Configuration
DEFAULT_API_BASE = "http://127.0.0.1:9090"
DEFAULT_REFRESH_INTERVAL = 5  # seconds
PROGRESS_BAR_WIDTH = 20

# ANSI color codes
class Colors:
    """ANSI color codes for terminal output."""
    RESET = '\033[0m'
    BOLD = '\033[1m'

    # Foreground colors
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GRAY = '\033[90m'
    WHITE = '\033[97m'

    # Background colors
    BG_GREEN = '\033[102m'
    BG_YELLOW = '\033[103m'
    BG_RED = '\033[101m'


class StatusMonitor:
    """Monitor and display orchestration status."""

    def __init__(self, api_base: str, refresh_interval: int, use_color: bool = True):
        self.api_base = api_base.rstrip('/')
        self.refresh_interval = refresh_interval
        self.use_color = use_color

    def _color(self, text: str, color_code: str) -> str:
        """Apply ANSI color to text if colors enabled."""
        if not self.use_color:
            return text
        return f"{color_code}{text}{Colors.RESET}"

    def _clear_screen(self):
        """Clear terminal screen and move cursor to top-left."""
        print('\033[2J\033[H', end='')

    def _make_request(self, endpoint: str) -> Optional[dict]:
        """Make HTTP request with error handling."""
        try:
            url = f"{self.api_base}{endpoint}"
            response = requests.get(url, timeout=5)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.ConnectionError:
            return None
        except requests.exceptions.Timeout:
            print(f"⚠ API timeout: {endpoint}")
            return None
        except requests.exceptions.RequestException as e:
            print(f"⚠ API error: {e}")
            return None

    def _get_streams(self) -> Optional[List[dict]]:
        """Get all streams from API."""
        data = self._make_request('/api/streams')
        if data is None:
            return None
        return data.get('streams', [])

    def _get_activity(self) -> Optional[List[dict]]:
        """Get recent agent activity from API."""
        data = self._make_request('/api/activity')
        if data is None:
            return None
        return data.get('activity', [])

    def _progress_bar(self, percentage: float, width: int = PROGRESS_BAR_WIDTH) -> str:
        """Create Unicode progress bar."""
        filled = int(width * percentage / 100)
        empty = width - filled
        bar = '█' * filled + '░' * empty

        # Color based on completion
        if percentage >= 100:
            return self._color(bar, Colors.GREEN)
        elif percentage >= 1:
            return self._color(bar, Colors.YELLOW)
        else:
            return self._color(bar, Colors.GRAY)

    def _format_percentage(self, percentage: float) -> str:
        """Format percentage with color."""
        text = f"{percentage:5.1f}%"
        if percentage >= 100:
            return self._color(text, Colors.GREEN + Colors.BOLD)
        elif percentage >= 1:
            return self._color(text, Colors.YELLOW)
        else:
            return self._color(text, Colors.GRAY)

    def _status_icon(self, status: str) -> str:
        """Get colored status icon."""
        icons = {
            'completed': self._color('✓', Colors.GREEN + Colors.BOLD),
            'in_progress': self._color('●', Colors.YELLOW),
            'pending': self._color('○', Colors.GRAY),
            'blocked': self._color('⚫', Colors.RED + Colors.BOLD)
        }
        return icons.get(status.lower(), '?')

    def _group_by_phase(self, streams: List[dict]) -> Dict[str, List[dict]]:
        """Group streams by phase."""
        phases = {
            'foundation': [],
            'parallel': [],
            'integration': []
        }

        for stream in streams:
            phase = stream.get('phase', 'parallel')
            if phase in phases:
                phases[phase].append(stream)

        return phases

    def _calculate_overall_progress(self, streams: List[dict]) -> Tuple[int, int, float]:
        """Calculate overall task progress."""
        total_tasks = 0
        completed_tasks = 0

        for stream in streams:
            total_tasks += stream.get('totalTasks', 0)
            completed_tasks += stream.get('completedTasks', 0)

        percentage = (completed_tasks / total_tasks * 100) if total_tasks > 0 else 0
        return completed_tasks, total_tasks, percentage

    def _render_header(self, timestamp: str):
        """Render monitor header."""
        width = 70
        print('╔' + '═' * (width - 2) + '╗')

        title = "ORCHESTRATION STATUS"
        refresh_text = f"[Refresh: {self.refresh_interval}s]"
        padding = width - len(title) - len(refresh_text) - 4

        header = f"║  {self._color(title, Colors.BOLD + Colors.CYAN)}{' ' * padding}{refresh_text}   ║"
        print(header)

        print('╠' + '═' * (width - 2) + '╣')

    def _render_overall_progress(self, completed: int, total: int, percentage: float):
        """Render overall progress bar."""
        bar = self._progress_bar(percentage)
        pct = self._format_percentage(percentage)
        task_count = f"({completed}/{total} tasks)"

        # Calculate visible length (without ANSI codes)
        visible_content = f"Overall: {'█' * PROGRESS_BAR_WIDTH} {percentage:5.1f}% {task_count}"
        padding = 68 - len(visible_content) - 2

        print(f"║  Overall: {bar} {pct} {self._color(task_count, Colors.WHITE)}{' ' * max(0, padding)}║")
        print('╠' + '═' * 68 + '╣')

    def _render_stream(self, stream: dict, activity: List[dict]):
        """Render single stream with activity."""
        stream_id = stream.get('streamId', 'Unknown')
        stream_name = stream.get('name', 'unnamed')
        phase = stream.get('phase', 'parallel')
        total_tasks = stream.get('totalTasks', 0)
        completed_tasks = stream.get('completedTasks', 0)
        status = stream.get('status', 'pending')

        percentage = (completed_tasks / total_tasks * 100) if total_tasks > 0 else 0
        bar = self._progress_bar(percentage, 20)
        pct = self._format_percentage(percentage)
        icon = self._status_icon(status)

        # Stream header line
        stream_label = self._color(f"{stream_id}", Colors.BOLD + Colors.WHITE)
        phase_label = self._color(f"({phase})", Colors.GRAY)

        if status.lower() == 'completed':
            status_text = self._color("✓ COMPLETE", Colors.GREEN + Colors.BOLD)
            task_text = ""
        else:
            status_text = ""
            task_text = self._color(f"({completed_tasks}/{total_tasks} tasks)", Colors.WHITE)

        # Calculate visible length (without ANSI codes)
        # Format: "  {stream_id} ({phase})  {bar} {pct} {status_or_tasks}"
        bar_plain = '█' * 20  # Progress bar visual width
        pct_plain = f"{percentage:5.1f}%"

        if status.lower() == 'completed':
            suffix = "✓ COMPLETE"
            visible_content = f"  {stream_id} ({phase})  {bar_plain} {pct_plain} {suffix}"
            line = f"║  {stream_label} {phase_label}  {bar} {pct} {status_text}"
        else:
            suffix = f"({completed_tasks}/{total_tasks} tasks)"
            visible_content = f"  {stream_id} ({phase})  {bar_plain} {pct_plain} {suffix}"
            line = f"║  {stream_label} {phase_label}  {bar} {pct} {task_text}"

        # Pad to 68 characters (70 - 2 for border chars)
        padding = 68 - len(visible_content)
        print(line + ' ' * max(0, padding) + '║')

        # Find agent activity for this stream
        stream_activity = [a for a in activity if a.get('streamId') == stream_id]
        if stream_activity and status.lower() not in ['completed', 'pending']:
            latest = stream_activity[0]
            agent = latest.get('agent', 'unknown')
            action = latest.get('action', 'working')

            # Calculate visible content for padding
            activity_plain = f"    └─ @agent-{agent}: {action}"
            # Truncate if too long
            if len(activity_plain) > 64:
                action = action[:64 - len(f"    └─ @agent-{agent}: ") - 3] + "..."
                activity_plain = f"    └─ @agent-{agent}: {action}"

            activity_text = self._color(f"    └─ @agent-{agent}: {action}", Colors.CYAN)
            padding = 68 - len(activity_plain) - 2
            print(f"║  {activity_text}{' ' * max(0, padding)}║")

    def _render_alerts(self, streams: List[dict]):
        """Render alerts section for blocked streams."""
        blocked = [s for s in streams if s.get('status', '').lower() == 'blocked']

        if not blocked:
            return

        print('╠' + '═' * 68 + '╣')
        alerts_header = self._color("ALERTS", Colors.RED + Colors.BOLD)
        print(f"║  {alerts_header}{' ' * 61}║")

        for stream in blocked:
            stream_id = stream.get('streamId', 'Unknown')
            reason = stream.get('blockedReason', 'Unknown reason')

            alert_text = f"⚠ {stream_id}: {reason}"
            # Truncate if too long
            if len(alert_text) > 64:
                alert_text = alert_text[:61] + "..."

            colored_alert = self._color(alert_text, Colors.RED)
            print(f"║  {colored_alert}{' ' * (68 - len(alert_text))}║")

    def _render_footer(self):
        """Render monitor footer."""
        print('╚' + '═' * 68 + '╝')

        footer_text = self._color("Press Ctrl+C to exit", Colors.GRAY)
        print(f"\n{footer_text}")

    def _render_error_screen(self, error_message: str):
        """Render error state."""
        self._clear_screen()

        width = 70
        print('╔' + '═' * (width - 2) + '╗')

        title = "ORCHESTRATION STATUS - ERROR"
        print(f"║  {self._color(title, Colors.RED + Colors.BOLD)}{' ' * (width - len(title) - 4)}║")
        print('╠' + '═' * (width - 2) + '╣')

        error_lines = error_message.split('\n')
        for line in error_lines:
            if len(line) > width - 6:
                line = line[:width - 9] + "..."
            padding = width - len(line) - 6
            print(f"║  {self._color(line, Colors.RED)}{' ' * padding}  ║")

        print('╚' + '═' * (width - 2) + '╝')

    def display(self):
        """Display current status once."""
        streams = self._get_streams()
        activity = self._get_activity()

        if streams is None:
            self._render_error_screen(
                f"Cannot connect to Task Copilot API\n"
                f"URL: {self.api_base}\n\n"
                f"Ensure Task Copilot HTTP server is running:\n"
                f"  Check .mcp.json configuration\n"
                f"  Verify HTTP_PORT environment variable"
            )
            return

        if not streams:
            self._render_error_screen(
                "No active streams found\n\n"
                "Run /protocol to start an initiative\n"
                "Define streams in your PRD"
            )
            return

        # Clear screen and render
        self._clear_screen()

        timestamp = datetime.now().strftime("%H:%M:%S")
        self._render_header(timestamp)

        # Overall progress
        completed, total, percentage = self._calculate_overall_progress(streams)
        self._render_overall_progress(completed, total, percentage)

        # Group by phase
        phases = self._group_by_phase(streams)

        # Render each phase
        for phase_name in ['foundation', 'parallel', 'integration']:
            phase_streams = phases[phase_name]
            if phase_streams:
                for stream in phase_streams:
                    self._render_stream(stream, activity or [])

        # Alerts
        self._render_alerts(streams)

        # Footer
        self._render_footer()

    def watch(self):
        """Continuously watch and display status."""
        print(self._color(f"\nStarting orchestration monitor...", Colors.CYAN))
        print(self._color(f"API: {self.api_base}", Colors.GRAY))
        print(self._color(f"Refresh interval: {self.refresh_interval}s\n", Colors.GRAY))
        time.sleep(1)

        try:
            while True:
                self.display()
                time.sleep(self.refresh_interval)
        except KeyboardInterrupt:
            self._clear_screen()
            print(self._color("\n✓ Monitoring stopped", Colors.GREEN))
            print(self._color("Orchestration sessions continue running in background\n", Colors.GRAY))
            sys.exit(0)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Monitor Claude Code orchestration status',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 watch-status.py                # Default 5s refresh
  python3 watch-status.py --refresh 10   # Custom refresh interval
  python3 watch-status.py --no-color     # Disable colors
        """
    )

    parser.add_argument(
        '--refresh',
        type=int,
        default=DEFAULT_REFRESH_INTERVAL,
        metavar='SECONDS',
        help=f'Refresh interval in seconds (default: {DEFAULT_REFRESH_INTERVAL})'
    )

    parser.add_argument(
        '--no-color',
        action='store_true',
        help='Disable ANSI color codes'
    )

    parser.add_argument(
        '--api',
        type=str,
        default=DEFAULT_API_BASE,
        metavar='URL',
        help=f'Task Copilot API base URL (default: {DEFAULT_API_BASE})'
    )

    args = parser.parse_args()

    # Validate refresh interval
    if args.refresh < 1:
        print("Error: Refresh interval must be at least 1 second")
        sys.exit(1)

    # Create monitor
    monitor = StatusMonitor(
        api_base=args.api,
        refresh_interval=args.refresh,
        use_color=not args.no_color
    )

    # Start watching
    monitor.watch()


if __name__ == '__main__':
    main()
