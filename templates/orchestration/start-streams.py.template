#!/usr/bin/env python3
"""
Claude Code Parallel Stream Orchestration

Manages multiple Claude Code sessions running in parallel for independent work streams.

Features:
- tmux session management (creates windows per stream)
- Claude Code invocation with /continue {streamId}
- Dependency polling (checks Task Copilot API every 30s)
- Phase ordering (foundation → parallel → integration)
- Max 5 parallel streams enforced
- Retry logic with exponential backoff
- Desktop notifications (macOS)
- Graceful error handling

Generated by: /orchestration command
Configuration: orchestration-config.json

Usage:
    python3 start-streams.py              # Start all streams
    python3 start-streams.py --dry-run    # Preview without starting
    python3 start-streams.py --stream X   # Start specific stream
    python3 start-streams.py --status     # Show current status
"""

import json
import subprocess
import time
import sys
import argparse
import os
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime

try:
    import requests
except ImportError:
    print("Error: 'requests' library not found")
    print("Install with: pip install requests")
    sys.exit(1)

# Configuration
CONFIG_FILE = Path(__file__).parent / "orchestration-config.json"
DEFAULT_API_BASE = "http://127.0.0.1:9090"
DEFAULT_POLL_INTERVAL = 30  # seconds
DEFAULT_MAX_PARALLEL = 5
MAX_RETRIES = 3
RETRY_BACKOFF_BASE = 2  # exponential backoff: 2^attempt seconds

# Context recovery configuration
DEFAULT_STALL_TIMEOUT_MINUTES = 10  # Consider stalled if no progress for 10 minutes
DEFAULT_AUTO_RECOVERY = True        # Auto-restart stalled streams
DEFAULT_MAX_RECOVERY_ATTEMPTS = 3   # Max restarts per stream

# Context exhaustion detection patterns
CONTEXT_EXHAUSTION_PATTERNS = [
    "context window exceeded",
    "conversation compacted",
    "maximum context",
    "context limit reached",
    "The conversation is too long",
]

# tmux session name
TMUX_SESSION = "claude-streams"


@dataclass
class StreamStatus:
    """Current status of a stream from Task Copilot API."""
    stream_id: str
    stream_name: str
    stream_phase: str
    total_tasks: int
    completed_tasks: int
    in_progress_tasks: int
    progress_percentage: float
    dependencies: List[str]
    worktree_path: Optional[str]


@dataclass
class StreamHealthState:
    """Tracks health state for context recovery detection."""
    stream_id: str
    last_progress: float
    last_progress_time: datetime
    recovery_attempts: int = 0
    last_recovery_time: Optional[datetime] = None
    is_stalled: bool = False


class OrchestrationManager:
    """Manages parallel Claude Code sessions via tmux."""

    def __init__(self, config_path: Path):
        self.config = self._load_config(config_path)
        self.api_base = self.config.get("apiBaseUrl", DEFAULT_API_BASE)
        self.poll_interval = self.config.get("pollInterval", DEFAULT_POLL_INTERVAL)
        self.max_parallel = self.config.get("maxParallelStreams", DEFAULT_MAX_PARALLEL)
        self.tmux_windows: Dict[str, str] = {}  # stream_id -> window_id

        # Context recovery configuration
        recovery_config = self.config.get("contextRecovery", {})
        self.stall_timeout_minutes = recovery_config.get(
            "stallTimeoutMinutes", DEFAULT_STALL_TIMEOUT_MINUTES
        )
        self.auto_recovery_enabled = recovery_config.get(
            "autoRecoveryEnabled", DEFAULT_AUTO_RECOVERY
        )
        self.max_recovery_attempts = recovery_config.get(
            "maxRecoveryAttempts", DEFAULT_MAX_RECOVERY_ATTEMPTS
        )

        # Health tracking state (stream_id -> StreamHealthState)
        self.health_states: Dict[str, StreamHealthState] = {}

    def _load_config(self, path: Path) -> dict:
        """Load orchestration configuration."""
        if not path.exists():
            print(f"Error: Configuration file not found: {path}")
            print("Run /orchestration generate to create configuration")
            sys.exit(1)

        with open(path) as f:
            return json.load(f)

    def _retry_request(self, func, *args, **kwargs):
        """Retry HTTP request with exponential backoff."""
        for attempt in range(MAX_RETRIES):
            try:
                return func(*args, **kwargs)
            except requests.RequestException as e:
                if attempt == MAX_RETRIES - 1:
                    raise
                wait_time = RETRY_BACKOFF_BASE ** attempt
                print(f"  Retry {attempt + 1}/{MAX_RETRIES} after {wait_time}s: {e}")
                time.sleep(wait_time)

    def _check_api_health(self) -> bool:
        """Check if Task Copilot HTTP API is available."""
        try:
            response = self._retry_request(
                requests.get,
                f"{self.api_base}/health",
                timeout=5
            )
            return response.status_code == 200
        except requests.RequestException:
            return False

    def _get_stream_status(self, stream_id: str) -> Optional[StreamStatus]:
        """Query current stream status from API."""
        try:
            response = self._retry_request(
                requests.get,
                f"{self.api_base}/api/streams/{stream_id}",
                timeout=5
            )

            if response.status_code == 404:
                return None

            data = response.json()
            return StreamStatus(
                stream_id=data["streamId"],
                stream_name=data["streamName"],
                stream_phase=data["streamPhase"],
                total_tasks=data.get("totalTasks", 0),
                completed_tasks=data.get("completedTasks", 0),
                in_progress_tasks=data.get("inProgressTasks", 0),
                progress_percentage=data.get("progressPercentage", 0.0),
                dependencies=data.get("dependencies", []),
                worktree_path=data.get("worktreePath")
            )
        except requests.RequestException as e:
            print(f"Warning: Failed to get status for {stream_id}: {e}")
            return None

    def _are_dependencies_complete(self, stream_id: str) -> Tuple[bool, List[str]]:
        """
        Check if all stream dependencies are 100% complete.

        Returns:
            (all_complete, incomplete_deps)
        """
        stream_config = next(
            (s for s in self.config["streams"] if s["streamId"] == stream_id),
            None
        )
        if not stream_config:
            return False, []

        dependencies = stream_config.get("dependencies", [])
        if not dependencies:
            return True, []

        incomplete = []
        for dep_id in dependencies:
            status = self._get_stream_status(dep_id)
            if not status or status.progress_percentage < 100:
                incomplete.append(dep_id)

        return len(incomplete) == 0, incomplete

    def _check_tmux_installed(self) -> bool:
        """Check if tmux is installed."""
        try:
            subprocess.run(
                ["tmux", "-V"],
                capture_output=True,
                check=True
            )
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False

    def _tmux_session_exists(self) -> bool:
        """Check if tmux session already exists."""
        try:
            result = subprocess.run(
                ["tmux", "has-session", "-t", TMUX_SESSION],
                capture_output=True
            )
            return result.returncode == 0
        except Exception:
            return False

    def _create_tmux_session(self) -> bool:
        """Create tmux session for orchestration."""
        try:
            # Kill existing session if present
            if self._tmux_session_exists():
                print(f"Killing existing tmux session: {TMUX_SESSION}")
                subprocess.run(
                    ["tmux", "kill-session", "-t", TMUX_SESSION],
                    check=False
                )

            # Create new detached session
            subprocess.run(
                ["tmux", "new-session", "-d", "-s", TMUX_SESSION, "-n", "monitor"],
                check=True
            )
            return True
        except subprocess.CalledProcessError as e:
            print(f"Error creating tmux session: {e}")
            return False

    def _start_stream_in_tmux(self, stream_id: str) -> bool:
        """
        Start a Claude Code session for a stream in tmux window.

        Creates new tmux window, switches to correct directory, starts claude,
        and sends /continue {stream_id} command.
        """
        stream_config = next(
            (s for s in self.config["streams"] if s["streamId"] == stream_id),
            None
        )
        if not stream_config:
            print(f"Error: Stream {stream_id} not found in configuration")
            return False

        # Determine working directory
        project_root = Path(stream_config["projectRoot"]).expanduser().resolve()
        worktree_path = stream_config.get("worktreePath")

        if worktree_path:
            work_dir = project_root / worktree_path
        else:
            work_dir = project_root

        if not work_dir.exists():
            print(f"Error: Working directory does not exist: {work_dir}")
            print(f"  Run /continue {stream_id} to create worktree first")
            return False

        window_name = f"{stream_id}"

        try:
            # Create new window in tmux session
            subprocess.run(
                [
                    "tmux", "new-window",
                    "-t", TMUX_SESSION,
                    "-n", window_name,
                    "-c", str(work_dir)
                ],
                check=True
            )

            # Send claude command to start session
            subprocess.run(
                [
                    "tmux", "send-keys",
                    "-t", f"{TMUX_SESSION}:{window_name}",
                    "claude",
                    "C-m"  # Enter key
                ],
                check=True
            )

            # Wait for claude to start (2s)
            time.sleep(2)

            # Send /continue command
            subprocess.run(
                [
                    "tmux", "send-keys",
                    "-t", f"{TMUX_SESSION}:{window_name}",
                    f"/continue {stream_id}",
                    "C-m"
                ],
                check=True
            )

            self.tmux_windows[stream_id] = window_name
            print(f"✓ Started {stream_id} in tmux window '{window_name}'")
            return True

        except subprocess.CalledProcessError as e:
            print(f"Error starting stream in tmux: {e}")
            return False

    def _send_notification(self, title: str, message: str):
        """Send desktop notification (macOS only)."""
        if sys.platform != "darwin":
            return

        try:
            subprocess.run(
                [
                    "osascript", "-e",
                    f'display notification "{message}" with title "{title}"'
                ],
                check=False,
                capture_output=True
            )
        except Exception:
            pass  # Notifications are nice-to-have

    def _print_progress_bar(self, stream_id: str, status: StreamStatus):
        """Print ASCII progress bar for stream."""
        bar_length = 20
        filled = int(status.progress_percentage / 5)
        bar = "█" * filled + "░" * (bar_length - filled)

        print(f"{stream_id:12s} [{bar}] {status.progress_percentage:3.0f}% " +
              f"({status.completed_tasks}/{status.total_tasks} tasks)")

    # ==================== Context Recovery System ====================

    def _init_health_tracking(self, stream_id: str, initial_progress: float = 0.0):
        """Initialize health tracking state for a stream."""
        self.health_states[stream_id] = StreamHealthState(
            stream_id=stream_id,
            last_progress=initial_progress,
            last_progress_time=datetime.now(),
            recovery_attempts=0,
            last_recovery_time=None,
            is_stalled=False
        )

    def _update_health_tracking(self, stream_id: str, current_progress: float) -> bool:
        """
        Update health tracking and detect stalls.

        Returns True if stream is making progress, False if stalled.
        """
        if stream_id not in self.health_states:
            self._init_health_tracking(stream_id, current_progress)
            return True

        state = self.health_states[stream_id]
        now = datetime.now()

        # Check for progress
        if current_progress > state.last_progress:
            # Progress made - reset tracking
            state.last_progress = current_progress
            state.last_progress_time = now
            state.is_stalled = False
            return True

        # No progress - check if stalled
        minutes_since_progress = (now - state.last_progress_time).total_seconds() / 60

        if minutes_since_progress >= self.stall_timeout_minutes:
            state.is_stalled = True
            return False

        return True

    def _check_tmux_for_exhaustion(self, stream_id: str) -> bool:
        """
        Check tmux window output for context exhaustion patterns.

        Returns True if context exhaustion detected.
        """
        window_name = self.tmux_windows.get(stream_id)
        if not window_name:
            return False

        try:
            # Capture last 100 lines of tmux output
            result = subprocess.run(
                [
                    "tmux", "capture-pane",
                    "-t", f"{TMUX_SESSION}:{window_name}",
                    "-p", "-S", "-100"
                ],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode != 0:
                return False

            output = result.stdout.lower()

            # Check for exhaustion patterns
            for pattern in CONTEXT_EXHAUSTION_PATTERNS:
                if pattern.lower() in output:
                    print(f"⚠ Context exhaustion detected in {stream_id}: '{pattern}'")
                    return True

            return False

        except (subprocess.TimeoutExpired, subprocess.CalledProcessError):
            return False

    def _kill_stream_window(self, stream_id: str) -> bool:
        """Kill tmux window for a stream."""
        window_name = self.tmux_windows.get(stream_id)
        if not window_name:
            return False

        try:
            subprocess.run(
                [
                    "tmux", "kill-window",
                    "-t", f"{TMUX_SESSION}:{window_name}"
                ],
                check=True,
                capture_output=True
            )
            del self.tmux_windows[stream_id]
            return True
        except subprocess.CalledProcessError:
            return False

    def _recover_stream(self, stream_id: str) -> bool:
        """
        Attempt to recover a stalled or context-exhausted stream.

        1. Kill existing tmux window
        2. Create new window
        3. Start Claude with /continue {stream_id}

        Returns True if recovery successful.
        """
        state = self.health_states.get(stream_id)
        if not state:
            return False

        # Check max recovery attempts
        if state.recovery_attempts >= self.max_recovery_attempts:
            print(f"✗ {stream_id}: Max recovery attempts ({self.max_recovery_attempts}) reached")
            self._send_notification(
                "Recovery Failed",
                f"{stream_id} exceeded max recovery attempts"
            )
            return False

        print(f"⚠ Attempting recovery for {stream_id} (attempt {state.recovery_attempts + 1})")

        # Kill existing window
        self._kill_stream_window(stream_id)
        time.sleep(1)  # Brief pause

        # Start fresh
        success = self._start_stream_in_tmux(stream_id)

        if success:
            state.recovery_attempts += 1
            state.last_recovery_time = datetime.now()
            state.last_progress_time = datetime.now()  # Reset stall detection
            state.is_stalled = False

            print(f"✓ {stream_id}: Recovery successful (attempt {state.recovery_attempts})")
            self._send_notification(
                "Stream Recovered",
                f"{stream_id} restarted (attempt {state.recovery_attempts})"
            )
        else:
            print(f"✗ {stream_id}: Recovery failed")
            self._send_notification(
                "Recovery Failed",
                f"{stream_id} could not be restarted"
            )

        return success

    def _check_and_recover_streams(self, stream_ids: List[str]):
        """
        Check all streams for stalls/exhaustion and recover if needed.

        Called during the monitoring loop.
        """
        if not self.auto_recovery_enabled:
            return

        for stream_id in stream_ids:
            # Skip if not in tmux
            if stream_id not in self.tmux_windows:
                continue

            # Get current status
            status = self._get_stream_status(stream_id)
            if not status:
                continue

            # Skip complete streams
            if status.progress_percentage >= 100:
                continue

            # Update health tracking
            is_healthy = self._update_health_tracking(stream_id, status.progress_percentage)

            # Check for explicit context exhaustion
            is_exhausted = self._check_tmux_for_exhaustion(stream_id)

            # Trigger recovery if needed
            if not is_healthy or is_exhausted:
                reason = "context exhaustion" if is_exhausted else "stall detected"
                print(f"⚠ {stream_id}: {reason} - initiating recovery")
                self._recover_stream(stream_id)

    # ==================== End Context Recovery System ====================

    def show_status(self):
        """Display current status of all streams."""
        print("=" * 70)
        print("Stream Status")
        print("=" * 70)
        print()

        streams = self.config.get("streams", [])
        if not streams:
            print("No streams configured")
            return

        plan = self.config.get("executionPlan", {})

        # Foundation
        foundation = plan.get("foundation", [])
        if foundation:
            print("Foundation Phase")
            print("-" * 70)
            for stream_id in foundation:
                status = self._get_stream_status(stream_id)
                if status:
                    self._print_progress_bar(stream_id, status)
            print()

        # Parallel
        parallel = plan.get("parallel", [])
        if parallel:
            print("Parallel Phase")
            print("-" * 70)
            for stream_id in parallel:
                status = self._get_stream_status(stream_id)
                if status:
                    self._print_progress_bar(stream_id, status)
                    deps_complete, incomplete = self._are_dependencies_complete(stream_id)
                    if not deps_complete:
                        print(f"  ⚠ Waiting on: {', '.join(incomplete)}")
            print()

        # Integration
        integration = plan.get("integration", [])
        if integration:
            print("Integration Phase")
            print("-" * 70)
            for stream_id in integration:
                status = self._get_stream_status(stream_id)
                if status:
                    self._print_progress_bar(stream_id, status)
                    deps_complete, incomplete = self._are_dependencies_complete(stream_id)
                    if incomplete:
                        print(f"  ⚠ Waiting on: {', '.join(incomplete)}")
            print()

    def dry_run(self, specific_stream: Optional[str] = None):
        """Preview orchestration plan without starting sessions."""
        print("=" * 70)
        print("Orchestration Dry Run")
        print("=" * 70)
        print()

        print(f"Configuration: {CONFIG_FILE}")
        print(f"API Endpoint: {self.api_base}")
        print(f"Max Parallel Streams: {self.max_parallel}")
        print(f"Poll Interval: {self.poll_interval}s")
        print()

        # Check API
        print("Checking Task Copilot HTTP API...")
        if self._check_api_health():
            print("✓ API is healthy")
        else:
            print("⚠ API not available - orchestration will fail")
        print()

        # Check tmux
        print("Checking tmux...")
        if self._check_tmux_installed():
            print("✓ tmux is installed")
        else:
            print("⚠ tmux not installed - required for orchestration")
        print()

        plan = self.config.get("executionPlan", {})

        if specific_stream:
            # Show plan for specific stream
            stream_config = next(
                (s for s in self.config["streams"] if s["streamId"] == specific_stream),
                None
            )
            if not stream_config:
                print(f"Error: Stream {specific_stream} not found")
                return

            print(f"Stream: {specific_stream}")
            print(f"  Name: {stream_config['streamName']}")
            print(f"  Phase: {stream_config['streamPhase']}")
            print(f"  Tasks: {stream_config['totalTasks']}")
            print(f"  Dependencies: {', '.join(stream_config.get('dependencies', [])) or 'None'}")
            print(f"  Worktree: {stream_config.get('worktreePath', 'main')}")
            return

        # Show full execution plan
        print("Execution Plan:")
        print()

        print("Phase 1: Foundation")
        for stream_id in plan.get("foundation", []):
            print(f"  - {stream_id} (must complete before parallel work)")
        print()

        print(f"Phase 2: Parallel (max {self.max_parallel} concurrent)")
        for stream_id in plan.get("parallel", []):
            stream = next(s for s in self.config["streams"] if s["streamId"] == stream_id)
            deps = stream.get("dependencies", [])
            print(f"  - {stream_id}")
            if deps:
                print(f"      Depends on: {', '.join(deps)}")
        print()

        print("Phase 3: Integration")
        for stream_id in plan.get("integration", []):
            print(f"  - {stream_id} (merges parallel work)")
        print()

        print("To execute: python3 start-streams.py")

    def run_orchestration(self, specific_stream: Optional[str] = None):
        """Execute the orchestration plan."""
        print("=" * 70)
        print("Claude Code Parallel Stream Orchestration")
        print("=" * 70)
        print()

        # Check prerequisites
        print("Checking prerequisites...")

        # Check API
        if not self._check_api_health():
            print("✗ Task Copilot HTTP API is not available")
            print("  Ensure Task Copilot MCP server is running with HTTP_API_PORT")
            print("  Add to .mcp.json: { \"HTTP_API_PORT\": \"9090\" }")
            sys.exit(1)
        print("✓ Task Copilot API is healthy")

        # Check tmux
        if not self._check_tmux_installed():
            print("✗ tmux is not installed")
            print("  Install with: brew install tmux (macOS)")
            sys.exit(1)
        print("✓ tmux is installed")
        print()

        # Get execution plan
        plan = self.config["executionPlan"]

        # Handle specific stream request
        if specific_stream:
            print(f"Starting specific stream: {specific_stream}")
            print()

            # Check dependencies
            deps_complete, incomplete = self._are_dependencies_complete(specific_stream)
            if not deps_complete:
                print(f"✗ Dependencies not complete: {', '.join(incomplete)}")
                print("  Complete dependencies first:")
                for dep in incomplete:
                    print(f"    /continue {dep}")
                sys.exit(1)

            # Create tmux session
            if not self._create_tmux_session():
                print("✗ Failed to create tmux session")
                sys.exit(1)

            # Start stream
            if self._start_stream_in_tmux(specific_stream):
                print()
                print(f"✓ Stream {specific_stream} started successfully")
                print(f"  Attach to session: tmux attach -t {TMUX_SESSION}")
                self._send_notification(
                    "Stream Started",
                    f"{specific_stream} is running"
                )
            else:
                print(f"✗ Failed to start stream {specific_stream}")
                sys.exit(1)
            return

        # Full orchestration
        # Phase 1: Foundation
        print("Phase 1: Foundation Streams")
        print("-" * 70)

        foundation_streams = plan.get("foundation", [])
        for stream_id in foundation_streams:
            status = self._get_stream_status(stream_id)
            if status and status.progress_percentage >= 100:
                print(f"✓ {stream_id} already complete")
            else:
                print(f"⚠ {stream_id} needs completion")
                print(f"  Run: /continue {stream_id}")
                print(f"  This is foundation - must complete before parallel work")

        print()
        input("Press Enter when foundation streams are 100% complete...")
        print()

        # Verify foundation complete
        foundation_complete = True
        for stream_id in foundation_streams:
            status = self._get_stream_status(stream_id)
            if not status or status.progress_percentage < 100:
                print(f"✗ {stream_id} not complete ({status.progress_percentage:.0f}%)")
                foundation_complete = False

        if not foundation_complete:
            print()
            print("Error: Foundation streams not complete. Exiting.")
            sys.exit(1)

        print("✓ All foundation streams complete")
        print()

        # Phase 2: Parallel Streams
        print("Phase 2: Parallel Streams")
        print("-" * 70)

        parallel_streams = plan.get("parallel", [])

        # Enforce max parallel limit
        if len(parallel_streams) > self.max_parallel:
            print(f"⚠ Warning: {len(parallel_streams)} streams exceeds limit of {self.max_parallel}")
            print(f"  Only first {self.max_parallel} will be started")
            parallel_streams = parallel_streams[:self.max_parallel]

        # Create tmux session
        if not self._create_tmux_session():
            print("✗ Failed to create tmux session")
            sys.exit(1)
        print(f"✓ Created tmux session: {TMUX_SESSION}")
        print()

        # Start parallel streams
        print(f"Starting {len(parallel_streams)} parallel streams...")
        started = []
        failed = []

        for stream_id in parallel_streams:
            # Check dependencies
            deps_complete, incomplete = self._are_dependencies_complete(stream_id)
            if not deps_complete:
                print(f"⚠ Skipping {stream_id} - dependencies incomplete: {', '.join(incomplete)}")
                failed.append(stream_id)
                continue

            # Start stream
            if self._start_stream_in_tmux(stream_id):
                started.append(stream_id)
            else:
                print(f"✗ Failed to start {stream_id}")
                failed.append(stream_id)
                # Continue with other streams

        print()
        print(f"Started {len(started)}/{len(parallel_streams)} streams successfully")
        if failed:
            print(f"Failed/Skipped: {', '.join(failed)}")
        print()

        if not started:
            print("No streams started. Exiting.")
            sys.exit(1)

        # Attach instructions
        print(f"Attach to tmux session: tmux attach -t {TMUX_SESSION}")
        print(f"Detach from session: Ctrl+B, then D")
        print(f"Switch windows: Ctrl+B, then <window-number>")
        print()
        print("Monitoring progress (Ctrl+C to stop monitoring)...")
        print()

        # Initialize health tracking for started streams
        for stream_id in started:
            status = self._get_stream_status(stream_id)
            initial_progress = status.progress_percentage if status else 0.0
            self._init_health_tracking(stream_id, initial_progress)

        # Monitor progress
        try:
            while True:
                all_complete = True

                for stream_id in started:
                    status = self._get_stream_status(stream_id)
                    if not status:
                        continue

                    self._print_progress_bar(stream_id, status)

                    if status.progress_percentage < 100:
                        all_complete = False

                print()

                if all_complete:
                    print("✓ All parallel streams complete!")
                    self._send_notification(
                        "Orchestration Complete",
                        "All parallel streams finished"
                    )
                    break

                # Check for stalls/context exhaustion and recover if needed
                self._check_and_recover_streams(started)

                time.sleep(self.poll_interval)

        except KeyboardInterrupt:
            print()
            print("Monitoring stopped (streams still running in tmux)")
            print(f"To resume monitoring: python3 {sys.argv[0]} --status")
            sys.exit(0)

        # Phase 3: Integration
        integration_streams = plan.get("integration", [])
        if integration_streams:
            print()
            print("Phase 3: Integration Streams")
            print("-" * 70)
            for stream_id in integration_streams:
                deps_complete, incomplete = self._are_dependencies_complete(stream_id)
                if deps_complete:
                    print(f"✓ {stream_id} ready to start (dependencies complete)")
                else:
                    print(f"⚠ {stream_id} waiting on: {', '.join(incomplete)}")
                print(f"  Run: /continue {stream_id}")

            print()
            print("Run integration streams manually to merge parallel work")

        print()
        print("=" * 70)
        print("Orchestration Complete!")
        print("=" * 70)
        print()
        print(f"tmux session '{TMUX_SESSION}' is still active")
        print(f"Kill session: tmux kill-session -t {TMUX_SESSION}")


def main():
    """Main entry point with CLI argument handling."""
    parser = argparse.ArgumentParser(
        description="Claude Code Parallel Stream Orchestration",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                    Start full orchestration
  %(prog)s --dry-run          Preview without starting
  %(prog)s --stream Stream-B  Start specific stream
  %(prog)s --status           Show current progress

For more information, see README.md in this directory.
        """
    )

    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Preview orchestration plan without starting sessions"
    )

    parser.add_argument(
        "--stream",
        type=str,
        metavar="STREAM_ID",
        help="Start specific stream only"
    )

    parser.add_argument(
        "--status",
        action="store_true",
        help="Show current stream status"
    )

    args = parser.parse_args()

    # Load configuration
    manager = OrchestrationManager(CONFIG_FILE)

    # Route to appropriate action
    if args.status:
        manager.show_status()
    elif args.dry_run:
        manager.dry_run(specific_stream=args.stream)
    else:
        manager.run_orchestration(specific_stream=args.stream)


if __name__ == "__main__":
    main()
